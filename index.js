import { Telegraf, session } from 'telegraf';
import axios from 'axios';
import dotenv from 'dotenv';
import express from 'express';
import fs from 'fs';

dotenv.config();

const bot = new Telegraf(process.env.BOT_TOKEN);

bot.use(session());
bot.use((ctx, next) => {
  if (!ctx.session) ctx.session = {};
  return next();
});

// ------------------ –†–∞–±–æ—Ç–∞ —Å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º ------------------
const ALERTS_FILE = 'alerts.json';

function loadAlerts() {
  try {
    if (fs.existsSync(ALERTS_FILE)) {
      return JSON.parse(fs.readFileSync(ALERTS_FILE, 'utf8'));
    }
    return [];
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ alerts.json:', err);
    return [];
  }
}

function saveAlerts() {
  try {
    fs.writeFileSync(ALERTS_FILE, JSON.stringify(alerts, null, 2), 'utf8');
  } catch (err) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è alerts.json:', err);
  }
}

let alerts = loadAlerts();
// ---------------------------------------------------------

// ------------------ HTTP —Å–µ—Ä–≤–µ—Ä –¥–ª—è Render + UptimeRobot ------------------
const app = express();
app.get('/', (req, res) => res.send('–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç! üöÄ'));

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üåê HTTP —Å–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`));
// ---------------------------------------------------------

// ------------------ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –æ—à–∏–±–æ–∫ ------------------
process.on('uncaughtException', err => {
  console.error('–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞:', err);
});
process.on('unhandledRejection', reason => {
  console.error('–ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –æ–±–µ—â–∞–Ω–∏–µ:', reason);
});
// ---------------------------------------------------------

const mainMenu = {
  reply_markup: {
    keyboard: [
      [{ text: '‚ûï –°–æ–∑–¥–∞—Ç—å –∞–ª–µ—Ä—Ç' }, { text: 'üìã –ú–æ–∏ –∞–ª–µ—Ä—Ç—ã' }]
    ],
    resize_keyboard: true
  }
};

bot.start((ctx) => {
  ctx.session = {};
  ctx.reply('–ü—Ä–∏–≤–µ—Ç! üöÄ –Ø –±–æ—Ç –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ —Ü–µ–Ω–µ –∫—Ä–∏–ø—Ç—ã (KuCoin API).', mainMenu);
});

bot.hears('‚ûï –°–æ–∑–¥–∞—Ç—å –∞–ª–µ—Ä—Ç', (ctx) => {
  ctx.session = { step: 'symbol' };
  ctx.reply('–í–≤–µ–¥–∏ —Å–∏–º–≤–æ–ª –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: BTC):', {
    reply_markup: { keyboard: [[{ text: '‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞' }]], resize_keyboard: true }
  });
});

bot.hears('üìã –ú–æ–∏ –∞–ª–µ—Ä—Ç—ã', async (ctx) => {
  const userAlerts = alerts.filter(a => a.userId === ctx.from.id);
  if (userAlerts.length === 0) {
    return ctx.reply('–£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–ª–µ—Ä—Ç–æ–≤.', mainMenu);
  }

  let msg = 'üìã –¢–≤–æ–∏ –∞–ª–µ—Ä—Ç—ã:\n\n';
  for (let i = 0; i < userAlerts.length; i++) {
    const a = userAlerts[i];
    let currentPrice = '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
    try {
      const res = await axios.get(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${a.symbol}`);
      currentPrice = res.data.data?.price || '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
    } catch {}
    msg += `${i + 1}. ${a.symbol} ${a.condition} ${a.price} (—Ç–µ–∫—É—â–∞—è: ${currentPrice})\n`;
  }

  ctx.reply(msg, {
    reply_markup: {
      inline_keyboard: userAlerts.map((_, idx) => [
        { text: `‚ùå –£–¥–∞–ª–∏—Ç—å ${idx + 1}`, callback_data: `del_${idx}` }
      ])
    }
  });
});

bot.hears('‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞', (ctx) => {
  ctx.session = {};
  ctx.reply('–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ ‚úÖ', mainMenu);
});

bot.on('text', async (ctx) => {
  const step = ctx.session.step;
  const text = ctx.message.text.trim();

  if (!step) return;

  if (step === 'symbol') {
    const symbol = text.toUpperCase();
    const fullSymbol = `${symbol}-USDT`;

    try {
      const res = await axios.get(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${fullSymbol}`);
      if (!res.data.data) throw new Error();

      ctx.session.symbol = fullSymbol;
      ctx.session.step = 'condition';

      ctx.reply(`‚úÖ –ú–æ–Ω–µ—Ç–∞ –Ω–∞–π–¥–µ–Ω–∞: ${fullSymbol}\n–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: ${res.data.data.price}\n–í—ã–±–µ—Ä–∏ —É—Å–ª–æ–≤–∏–µ:`, {
        reply_markup: {
          keyboard: [
            [{ text: '‚¨ÜÔ∏è –ö–æ–≥–¥–∞ –≤—ã—à–µ' }, { text: '‚¨áÔ∏è –ö–æ–≥–¥–∞ –Ω–∏–∂–µ' }],
            [{ text: '‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞' }]
          ],
          resize_keyboard: true
        }
      });
    } catch {
      ctx.reply('‚ùå –¢–∞–∫–æ–π –ø–∞—Ä—ã –Ω–µ—Ç –Ω–∞ KuCoin. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥—É—é –º–æ–Ω–µ—Ç—É.');
    }

  } else if (step === 'condition') {
    if (text === '‚¨ÜÔ∏è –ö–æ–≥–¥–∞ –≤—ã—à–µ') ctx.session.condition = '>';
    else if (text === '‚¨áÔ∏è –ö–æ–≥–¥–∞ –Ω–∏–∂–µ') ctx.session.condition = '<';
    else return ctx.reply('–í—ã–±–µ—Ä–∏ –∏–∑ –∫–Ω–æ–ø–æ–∫ ‚¨ÜÔ∏è –∏–ª–∏ ‚¨áÔ∏è');

    ctx.session.step = 'price';
    ctx.reply('–í–≤–µ–¥–∏ —Ü–µ–Ω—É:', {
      reply_markup: { keyboard: [[{ text: '‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞' }]], resize_keyboard: true }
    });

  } else if (step === 'price') {
    const price = parseFloat(text);
    if (isNaN(price)) return ctx.reply('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ —Ü–µ–Ω—ã');

    ctx.session.price = price;

    try {
      const res = await axios.get(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${ctx.session.symbol}`);
      const currentPrice = parseFloat(res.data.data.price);

      alerts.push({
        userId: ctx.from.id,
        symbol: ctx.session.symbol,
        condition: ctx.session.condition,
        price: ctx.session.price
      });
      saveAlerts();

      ctx.reply(`‚úÖ –ê–ª–µ—Ä—Ç —Å–æ–∑–¥–∞–Ω: ${ctx.session.symbol} ${ctx.session.condition} ${ctx.session.price}\n–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: ${currentPrice}`, mainMenu);
      ctx.session = {};
    } catch {
      ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ü–µ–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.', mainMenu);
      ctx.session = {};
    }
  }
});

bot.on('callback_query', async (ctx) => {
  const data = ctx.callbackQuery.data;
  if (!data.startsWith('del_')) return;

  const index = parseInt(data.split('_')[1], 10);
  const userAlerts = alerts.filter(a => a.userId === ctx.from.id);

  if (index >= 0 && index < userAlerts.length) {
    const alertToRemove = userAlerts[index];
    alerts = alerts.filter(a => a !== alertToRemove);
    saveAlerts();

    const updatedAlerts = alerts.filter(a => a.userId === ctx.from.id);

    if (updatedAlerts.length === 0) {
      await ctx.editMessageText('–£ —Ç–µ–±—è –±–æ–ª—å—à–µ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–ª–µ—Ä—Ç–æ–≤.', {
        reply_markup: { inline_keyboard: [] }
      });
      await ctx.reply('–í—ã –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é', mainMenu);
      return;
    }

    let msg = 'üìã –¢–≤–æ–∏ –∞–ª–µ—Ä—Ç—ã:\n\n';
    for (let i = 0; i < updatedAlerts.length; i++) {
      const a = updatedAlerts[i];
      let currentPrice = '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
      try {
        const res = await axios.get(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${a.symbol}`);
        currentPrice = res.data.data?.price || '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
      } catch {}
      msg += `${i + 1}. ${a.symbol} ${a.condition} ${a.price} (—Ç–µ–∫—É—â–∞—è: ${currentPrice})\n`;
    }

    await ctx.editMessageText(msg, {
      reply_markup: {
        inline_keyboard: updatedAlerts.map((_, idx) => [
          { text: `‚ùå –£–¥–∞–ª–∏—Ç—å ${idx + 1}`, callback_data: `del_${idx}` }
        ])
      }
    });
  }

  await ctx.answerCbQuery();
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–ª–µ—Ä—Ç–æ–≤ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
setInterval(async () => {
  for (const alert of [...alerts]) {
    try {
      const res = await axios.get(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${alert.symbol}`);
      const currentPrice = parseFloat(res.data.data.price);

      if (
        (alert.condition === '>' && currentPrice > alert.price) ||
        (alert.condition === '<' && currentPrice < alert.price)
      ) {
        bot.telegram.sendMessage(alert.userId, `üîî ${alert.symbol} —Å–µ–π—á–∞—Å ${currentPrice}`);
        alerts = alerts.filter(a => a !== alert);
        saveAlerts();
      }
    } catch (err) {
      console.error(`–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã ${alert.symbol}`, err.message);
    }
  }
}, 60000);

bot.launch().then(() => console.log('üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω —Å KuCoin API'));
